        -:    0:Source:cardEffects.c
        -:    0:Graph:cardEffects.gcno
        -:    0:Data:cardEffects.gcda
        -:    0:Runs:5
        -:    0:Programs:5
        -:    1:#include "cardEffects.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <stdio.h>
        -:    4:
function baronCardEffect called 3 returned 100% blocks executed 91%
        3:    5:int baronCardEffect(struct gameState *state, int currentPlayer, int choice1)
        -:    6:{
        3:    7:    state->numBuys = state->numBuys + 2; //Increase buys by 1!
        3:    8:    if (choice1 > 0)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        -:    9:    {                               //Boolean true or going to discard an estate
        2:   10:        int p = 0;                  //Iterator for hand!
        2:   11:        int card_not_discarded = 1; //Flag for discard set!
       11:   12:        while (card_not_discarded)
branch  0 taken 78%
branch  1 taken 22% (fallthrough)
        -:   13:        {
        7:   14:            if (state->hand[currentPlayer][p] == estate)
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
        -:   15:            {                      //Found an estate card!
        1:   16:                state->coins += 4; //Add 4 coins to the amount of coins
        1:   17:                state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        1:   18:                state->discardCount[currentPlayer]++;
        -:   19:                //for (; p < state->handCount[currentPlayer]; p++)
        -:   20:                //{
        -:   21:                //    state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:   22:                //}
        -:   23:                //state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        1:   24:                state->handCount[currentPlayer]--;
        1:   25:                card_not_discarded = 0; //Exit the loop
        -:   26:            }
        6:   27:            else if (p > state->handCount[currentPlayer])
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        -:   28:            {
        -:   29:                if (DEBUG)
        -:   30:                {
        -:   31:                    printf("No estate cards in your hand, invalid choice\n");
        -:   32:                    printf("Must gain an estate if there are any\n");
        -:   33:                }
        1:   34:                if (supplyCount(estate, state) > 0)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:   35:                {
        1:   36:                    gainCard(estate, state, 0, currentPlayer);
call    0 returned 100%
        -:   37:
        1:   38:                    state->supplyCount[estate]--; //Decrement estates
        1:   39:                    if (supplyCount(estate, state) == 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   40:                    {
    #####:   41:                        isGameOver(state);
call    0 never executed
        -:   42:                    }
        -:   43:                }
        1:   44:                card_not_discarded = 0; //Exit the loop
        -:   45:            }
        -:   46:
        -:   47:            else
        -:   48:            {
        5:   49:                p++; //Next card
        -:   50:            }
        -:   51:        }
        -:   52:    }
        -:   53:
        -:   54:    else
        -:   55:    {
        1:   56:        if (supplyCount(estate, state) > 0)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:   57:        {
        1:   58:            gainCard(estate, state, 0, currentPlayer); //Gain an estate
call    0 returned 100%
        -:   59:
        1:   60:            state->supplyCount[estate]--; //Decrement Estates
        1:   61:            if (supplyCount(estate, state) == 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   62:            {
    #####:   63:                isGameOver(state);
call    0 never executed
        -:   64:            }
        -:   65:        }
        -:   66:    }
        -:   67:
        3:   68:    return 0;
        -:   69:}
        -:   70:
function minionCardEffect called 2 returned 100% blocks executed 96%
        2:   71:int minionCardEffect(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:   72:{
        -:   73:    //+1 action
        2:   74:    state->numActions++;
        -:   75:
        -:   76:    //discard card from hand
        2:   77:    discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:   78:
        2:   79:    if (choice1)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:   80:    {
        1:   81:        state->coins = state->coins + 2;
        -:   82:    }
        1:   83:    else if (choice2) //discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   84:    {
        -:   85:        //discard hand
        2:   86:        while (numHandCards(state) > 0)
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:   87:        {
    #####:   88:            discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:   89:        }
        -:   90:
        -:   91:        //draw 4
        6:   92:        for (int i = 0; i <= 4; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:   93:        {
        5:   94:            drawCard(currentPlayer, state);
call    0 returned 100%
        -:   95:        }
        -:   96:
        -:   97:        //other players discard hand and redraw if hand size > 4
        3:   98:        for (int i = 0; i < state->numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:   99:        {
        2:  100:            if (state->handCount[i] > 4)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  101:            {
        -:  102:                //discard hand
        7:  103:                while (state->handCount[i] > 0)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  104:                {
        5:  105:                    discardCard(handPos, i, state, 0);
call    0 returned 100%
        -:  106:                }
        -:  107:
        -:  108:                //draw 4
        5:  109:                for (int j = 0; j < 4; j++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  110:                {
        4:  111:                    drawCard(i, state);
call    0 returned 100%
        -:  112:                }
        -:  113:            }
        -:  114:        }
        -:  115:    }
        -:  116:
        2:  117:    return 0;
        -:  118:}
        -:  119:
function ambassadorCardEffect called 2 returned 100% blocks executed 96%
        2:  120:int ambassadorCardEffect(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  121:{
        2:  122:    int j = 0; //used to check if player has enough cards to discard
        -:  123:
        -:  124:    // if (choice2 > 2 || choice2 < 0)
        -:  125:    // {
        -:  126:    //     return -1;
        -:  127:    // }
        -:  128:
        -:  129:    // if (choice1 == handPos)
        -:  130:    // {
        -:  131:    //     return -1;
        -:  132:    // }
        -:  133:
       14:  134:    for (int i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
        -:  135:    {
       12:  136:        if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
branch  2 taken 20% (fallthrough)
branch  3 taken 80%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        -:  137:        {
        2:  138:            j++;
        -:  139:        }
        -:  140:    }
        -:  141:
        2:  142:    if (j < choice2)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  143:    {
        1:  144:        return -1;
        -:  145:    }
        -:  146:
        -:  147:    if (DEBUG)
        -:  148:        printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  149:
        -:  150:    //increase supply count for choosen card by amount being discarded
        -:  151:    
        1:  152:    state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  153:
        -:  154:    //each other player gains a copy of revealed card
        3:  155:    for (int i = 0; i < state->numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  156:    {
        2:  157:        if (i != currentPlayer)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  158:        {
        1:  159:            gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 returned 100%
        -:  160:        }
        -:  161:    }
        -:  162:
        -:  163:    //discard played card from hand
        1:  164:    discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  165:
        -:  166:    //trash copies of cards returned to supply
        2:  167:    for (j = 0; j < choice2; j++)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -:  168:    {
        1:  169:        for (int i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        -:  170:        {
        1:  171:            if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  172:            {
        1:  173:                discardCard(i, currentPlayer, state, 1);
call    0 returned 100%
        1:  174:                break;
        -:  175:            }
        -:  176:        }
        -:  177:    }
        -:  178:
        1:  179:    return -1;
        -:  180:}
        -:  181:
function tributeCardEffect called 5 returned 100% blocks executed 86%
        5:  182:int tributeCardEffect(struct gameState *state, int currentPlayer, int nextPlayer)
        -:  183:{
        5:  184:    int tributeRevealedCards[2] = {-1, -1};
        5:  185:    if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1)
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        -:  186:    {
        1:  187:        if (state->deckCount[nextPlayer] > 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  188:        {
    #####:  189:            tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  190:            state->deckCount[nextPlayer]--;
        -:  191:        }
        1:  192:        else if (state->discardCount[nextPlayer] > 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  193:        {
    #####:  194:            tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####:  195:            state->discardCount[nextPlayer]--;
        -:  196:        }
        -:  197:        else
        -:  198:        {
        -:  199:            //No Card to Reveal
        -:  200:            if (DEBUG)
        -:  201:            {
        -:  202:                printf("No cards to reveal\n");
        -:  203:            }
        -:  204:        }
        -:  205:    }
        -:  206:
        -:  207:    else
        -:  208:    {
        4:  209:        if (state->deckCount[nextPlayer] == 0)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:  210:        {
        2:  211:            for (int i = 0; i < state->discardCount[nextPlayer]; i++)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -:  212:            {
        1:  213:                state->deck[nextPlayer][i] = state->discard[nextPlayer][i]; //Move to deck
        1:  214:                state->deckCount[nextPlayer]++;
        1:  215:                state->discard[nextPlayer][i] = -1;
        1:  216:                state->discardCount[nextPlayer]--;
        -:  217:            }
        -:  218:
        1:  219:            shuffle(nextPlayer, state); //Shuffle the deck
call    0 returned 100%
        -:  220:        }
        4:  221:        tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        4:  222:        state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        4:  223:        state->deckCount[nextPlayer]--;
        4:  224:        tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        4:  225:        state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        4:  226:        state->deckCount[nextPlayer]--;
        -:  227:    }
        -:  228:
        5:  229:    if (tributeRevealedCards[0] == tributeRevealedCards[1])
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
        -:  230:    { //If we have a duplicate card, just drop one
        2:  231:        state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        2:  232:        state->playedCardCount++;
        2:  233:        tributeRevealedCards[1] = -1;
        -:  234:    }
        -:  235:
       20:  236:    for (int i = 0; i <= 2; i++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  237:    {
       15:  238:        if (tributeRevealedCards[i] == copper && tributeRevealedCards[i] == silver && tributeRevealedCards[i] == gold)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
        -:  239:        { //Treasure cards
    #####:  240:            state->coins += 2;
        -:  241:        }
        -:  242:
       15:  243:        else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 93% (fallthrough)
branch  5 taken 7%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
        -:  244:        { //Victory Card Found
        1:  245:            drawCard(2, state);
call    0 returned 100%
        -:  246:        }
        -:  247:        else
        -:  248:        { //Action Card
       14:  249:            state->numActions = state->numActions + 2;
        -:  250:        }
        -:  251:    }
        -:  252:
        5:  253:    return 0;
        -:  254:}
        -:  255:
function mineCardEffect called 1 returned 100% blocks executed 88%
        1:  256:int mineCardEffect(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  257:{
        1:  258:    int j = state->hand[currentPlayer][choice1]; //store card we will trash
        -:  259:
        -:  260:    // if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  261:    // {
        -:  262:    //     return -1;
        -:  263:    // }
        -:  264:
        1:  265:    if (choice2 > treasure_map || choice2 < curse)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  266:    {
    #####:  267:        return -1;
        -:  268:    }
        -:  269:
        1:  270:    if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  271:    {
    #####:  272:        return -1;
        -:  273:    }
        -:  274:
        1:  275:    gainCard(choice2, state, 2, currentPlayer);
call    0 returned 100%
        -:  276:
        -:  277:    //discard card from hand
        -:  278:    //discardCard(handPos, currentPlayer, state, 0);
        -:  279:
        -:  280:    //discard trashed card
        2:  281:    for (int i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        -:  282:    {
        2:  283:        if (state->hand[currentPlayer][i] == j)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  284:        {
        1:  285:            discardCard(i, currentPlayer, state, 0);
call    0 returned 100%
        1:  286:            break;
        -:  287:        }
        -:  288:    }
        -:  289:
        1:  290:    return 0;
        -:  291:}
